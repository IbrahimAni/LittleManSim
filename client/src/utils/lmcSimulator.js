/**
 * Little Man Computer (LMC) Simulator
 *
 * @class LMC
 */
class LMC {
  /**
   * Creates an instance of LMC.
   *
   * @param {number} [memorySize=100] - The size of the memory.
   */
  constructor(memorySize = 100) {
    this.memory = new Array(memorySize).fill("000");
    this.accumulator = 0;
    this.programCounter = 0;
    this.inputs = [];
    this.outputs = [];
    this.halted = false;
    this.isRunning = false;
    this.documentations = [];
    this.error = null;
    this.inputCallback = null;
    this.programIndices = [];
  }

  /**
   * Retrieves the current value of the accumulator.
   *
   * @returns {number} The value stored in the accumulator.
   */
  getAccumulator() {
    return this.accumulator;
  }

  /**
   * Retrieves the current value of the program counter.
   *
   * @returns {number} The current program counter value.
   */
  getProgramCounter() {
    return this.programCounter;
  }

  /**
   * Retrieves the entire memory array of the LMC.
   *
   * @returns {string[]} The memory array containing all instructions and data.
   */
  getMemory() {
    return this.memory;
  }

  /**
   * Retrieves the halted state of the LMC.
   *
   * @returns {boolean} `true` if the LMC is halted, otherwise `false`.
   */
  getHaltedSatate() {
    return this.halted;
  }

  /**
   * Retrieves the indices where the program and data are stored in memory.
   *
   * @returns {number[]} An array of memory indices used by the program.
   */
  getProgramIndices() {
    return this.programIndices;
  }

  /**
   * Retrieves the documentation associated with the LMC program.
   *
   * @returns {Array} An array containing documentation entries.
   */
  getDocumentations() {
    return this.documentations;
  }

  /**
   * Retrieves the output values generated by the LMC program.
   *
   * @returns {Array} An array of output values.
   */
  getOutputs() {
    return this.outputs;
  }

  /**
   * Sets the callback function to be used for input operations.
   *
   * @param {Function} callback - The function to be called when input is required.
   */
  setInputCallback(callback) {
    this.inputCallback = callback;
  }

  /**
   * Loads a program into the LMC memory.
   *
   * @param {number[]} program - An array of instructions to load into memory.
   */
  loadProgram(program, instructions = []) {
    // Reset the LMC state
    this.reset();

    if (program.length > 100) {
      throw new Error("Program size exceeds memory capacity.");
    }

    // Load program opcodes into memory
    program.forEach((instruction, index) => {
      if (instruction < 0 || instruction > 999) {
        throw new Error(
          `Invalid instruction at address ${index}: ${instruction}`
        );
      }
      this.memory[index] = instruction.toString().padStart(3, "0");
      this.programIndices.push(index);
    });

    if (instructions.length > 0) {
      // Load DAT values into memory
      instructions.forEach((instruction, index) => {
        if (instruction.data === "DAT") {
          const value =
            instruction.value === ""
              ? "000"
              : instruction.value.toString().padStart(3, "0");
          this.memory[index] = value;
          this.programIndices.push(index);
        }
      });
    }
  }

  /**
   * Executes a single instruction from memory.
   *
   * @throws {Error} If the program has halted or an invalid opcode is encountered.
   */
  step() {
    this.error = null;
    if (this.halted) {
      this.error = "Program has halted. Reset the program to run again.";
      throw new Error("Program is halted.");
    }

    if (this.programCounter < 0 || this.programCounter >= 100) {
      throw new Error(`Program counter out of bounds: ${this.programCounter}`);
    }

    const instruction = this.memory[this.programCounter];
    const opcode = Math.floor(instruction / 100);
    const address = instruction % 100;

    let docObj = {};

    switch (opcode) {
      case 1: // ADD
        this.accumulator += this.memory[address];

        docObj = {
          mnemonic: "ADD",
          opcode: instruction,
          mailbox: address,
          instruction: `ADD ${instruction}`,
          accumulator: this.accumulator,
          programCounter: this.programCounter + 1,
          comment: `ADD value at address ${address} to the value in the accumulator`,
        };
        this.documentations.push(docObj);
        break;
      case 2: // SUB
        // this.accumulator -= this.memory[address];
        this.accumulator -= this.memory[address];

        docObj = {
          mnemonic: "SUB",
          opcode: instruction,
          mailbox: address,
          instruction: `SUB ${instruction}`,
          accumulator: this.accumulator,
          programCounter: this.programCounter + 1,
          comment: `SUB value at address ${address} from the value in the accumulator`,
        };
        this.documentations.push(docObj);
        break;
      case 3: // STORE (STA)
        this.memory[address] = this.accumulator;

        docObj = {
          mnemonic: "STA",
          opcode: instruction,
          mailbox: address,
          instruction: `STA ${instruction}`,
          accumulator: this.accumulator,
          programCounter: this.programCounter + 1,
          comment: `STORE the value in the accumulator at ${address}`,
        };
        this.documentations.push(docObj);
        break;
      case 5: // LOAD (LDA)
        this.accumulator = this.memory[address];

        docObj = {
          mnemonic: "LDA",
          opcode: instruction,
          mailbox: address,
          instruction: `LDA ${instruction}`,
          accumulator: this.accumulator,
          programCounter: this.programCounter + 1,
          comment: `LOAD the value at ${address} into the accumulator`,
        };
        this.documentations.push(docObj);
        break;
      case 6: // BRANCH (BRA)
        this.programCounter = address;
        docObj = {
          mnemonic: "BRA",
          opcode: instruction,
          mailbox: address,
          instruction: `BRA ${instruction}`,
          accumulator: this.accumulator,
          programCounter: this.programCounter,
          comment: `BRANCH to ${address}`,
        };
        this.documentations.push(docObj);
        return; // prevent incrementing the program counter
      case 7: // BRANCH IF ZERO (BRZ)
        if (this.accumulator === 0) {
          this.programCounter = address;

          docObj = {
            mnemonic: "BRZ",
            opcode: instruction,
            mailbox: address,
            instruction: `BRZ ${instruction}`,
            accumulator: this.accumulator,
            programCounter: this.programCounter,
            comment: `BRANCH to ${address} if the accumulator value is zero`,
          };
          this.documentations.push(docObj);
          return; // prevent incrementing the program counter
        }
        break;
      case 8: // BRANCH IF POSITIVE (BRP)
        if (this.accumulator >= 0) {
          this.programCounter = address;
          docObj = {
            mnemonic: "BRP",
            opcode: instruction,
            mailbox: address,
            instruction: `BRP ${instruction}`,
            accumulator: this.accumulator,
            programCounter: this.programCounter,
            comment: `BRANCH to ${address} if the accumulator value is positive`,
          };
          this.documentations.push(docObj);
          return;
        }
        break;
      case 9: // IO Operations
        if (address === 1) {
          //INP
          if (this.inputs.length === 0) {
            if (this.inputCallback) {
              // Signal that inputs is required
              docObj = {
                mnemonic: "INP",
                opcode: instruction,
                mailbox: address,
                instruction: `INP ${address}`,
                accumulator: this.accumulator,
                programCounter: this.programCounter,
                comment: `INPUT required from the user`,
              };
              this.documentations.push(docObj);
              throw new Error("Input required"); // Custom error to signal input request
            } else {
              throw new Error("Input buffer is empty.");
            }
          }
          this.accumulator = this.inputs.shift();
          docObj = {
            mnemonic: "INP",
            opcode: instruction,
            mailbox: address,
            instruction: `INP ${address}`,
            accumulator: this.accumulator,
            programCounter: this.programCounter + 1,
            comment: `INPUT value from the input (${this.accumulator}) into the accumulator`,
          };
          this.documentations.push(docObj);
        } else if (address === 2) {
          //OUT
          this.outputs.push(this.accumulator);
          docObj = {
            mnemonic: "OUT",
            opcode: instruction,
            mailbox: address,
            instruction: `OUT ${instruction}`,
            accumulator: this.accumulator,
            programCounter: this.programCounter + 1,
            comment: `OUTPUT value from the accumulator (${this.accumulator}) to the outputs`,
          };
          this.documentations.push(docObj);
        } else {
          throw new Error(`Invalid IO operation: ${address}`);
        }
        break;
      case 0:
        this.halted = true;
        docObj = {
          mnemonic: "HLT",
          opcode: instruction,
          mailbox: address,
          instruction: `HLT ${instruction}`,
          accumulator: this.accumulator,
          programCounter: this.programCounter + 1,
          comment: `HALT program execution`,
        };
        this.documentations.push(docObj);
        break;
      default:
        throw new Error(`Invalid opcode: ${opcode}`);
    }
    this.programCounter++;
  }

  /**
   * Executes a single instruction from memory and logs the operation.
   */
  stepProgram() {
    this.step();
  }

  /**
   * Runs the loaded program until it halts.
   */
  run() {
    if (this.isRunning) {
      this.error = "Program is already running.";
    }

    this.isRunning = true;

    return new Promise((resolve, reject) => {
      const execute = () => {
        try {
          while (!this.halted && this.isRunning) {
            this.executeStep();
          }
          resolve();
        } catch (error) {
          reject(error);
        } finally {
          this.isRunning = false;
        }
      };

      setImmediate(execute);
    });
  }

  /**
   * Stop program execution.
   */
  stopExecution() {
    if (this.isRunning) {
      this.isRunning = false;
    }
  }

  /**
   * Resets the LMC to its initial state.
   */
  reset() {
    this.memory.fill("000");
    this.accumulator = 0;
    this.programCounter = 0;
    this.inputs = [];
    this.outputs = [];
    this.halted = false;
    this.documentations = [];
    this.error = null;
    this.isRunning = false;
    this.programIndices = [];
  }

  /**
   * Adds a value to the input queue.
   *
   * @param {number} value - The value to be added to the input queue.
   */
  setInbox(input) {
    this.inputs = input;
  }

  /**
   *
   * @param {number} address - The memory address to set the value.
   * @param {number} value - The value to set in the memory address.
   */
  setMemory(address, value) {
    this.memory[address] = value;
  }

  /**
   * Retrieves the logs.
   *
   * @returns {Array} The array of log entries.
   */
  getLogs() {
    return this.documentations;
  }

  /**
   * Clears the logs by resetting the logs array to an empty array.
   */
  clearLogs() {
    this.documentations = [];
  }

  convertToProgram(instructions) {
    let isDATPresent = false;

    instructions.forEach((instruction) => {
      if (instruction.data === "DAT") {
        isDATPresent = true;
      }
    });

    if (!isDATPresent) {
      return this.convertToProgramWithoutDAT(instructions);
    } else {
      return this.convertToProgramWithDAT(instructions);
    }
  }

  convertToProgramWithoutDAT(instructions) {
    let program = [];
    instructions.forEach((instruction) => {
      let opcode = 0;
      switch (instruction.mnemonic) {
        case "ADD":
          opcode = 100 + parseInt(instruction.address);
          break;
        case "SUB":
          opcode = 200 + parseInt(instruction.address);
          break;
        case "STA":
          opcode = 300 + parseInt(instruction.address);
          break;
        case "LDA":
          opcode = 500 + parseInt(instruction.address);
          break;
        case "BRA":
          opcode = 600 + parseInt(instruction.address);
          break;
        case "BRZ":
          opcode = 700 + parseInt(instruction.address);
          break;
        case "BRP":
          opcode = 800 + parseInt(instruction.address);
          break;
        case "INP":
          opcode = 901;
          break;
        case "OUT":
          opcode = 902;
          break;
        case "HLT":
          opcode = 0;
          break;
        default:
          opcode = 0;
      }
      program.push(opcode);
    });
    return program;
  }

  convertToProgramWithDAT(instructions) {
    // Create a map of labels and DAT addresses to their indices
    const labelMap = {};
    instructions.forEach((instruction, index) => {
      if (instruction.label) {
        labelMap[instruction.label] = index;
      }
      if (instruction.data === "DAT" && instruction.address) {
        labelMap[instruction.address] = index;
      }
    });

    // Assign opNumber to instructions referencing labels or numeric addresses
    instructions.forEach((instruction) => {
      // Handle mnemonic instructions (excluding DAT)
      if (
        instruction.mnemonic &&
        instruction.mnemonic !== "DAT" &&
        instruction.address
      ) {
        if (labelMap[instruction.address] !== undefined) {
          // Assign opNumber based on label/DAT index
          instruction.opNumber = labelMap[instruction.address].toString();
        } else {
          // If address is numeric, assign the parsed number as opNumber
          const parsedAddress = parseInt(instruction.address, 10);
          if (!isNaN(parsedAddress)) {
            instruction.opNumber = parsedAddress.toString();
          }
        }
      }

      // Handle DAT entries with numeric addresses
      if (instruction.data === "DAT" && instruction.address) {
        const parsedAddress = parseInt(instruction.address, 10);
        if (!isNaN(parsedAddress)) {
          instruction.opNumber = parsedAddress.toString();
        }
      }
    });

    // Generate program
    let program = [];
    instructions.forEach((instruction) => {
      if (instruction.data !== "DAT") {
        // Only process non-DAT instructions
        let opcode = 0;
        switch (instruction.mnemonic) {
          case "ADD":
            opcode = 100 + parseInt(instruction.opNumber);
            break;
          case "SUB":
            opcode = 200 + parseInt(instruction.opNumber);
            break;
          case "STA":
            opcode = 300 + parseInt(instruction.opNumber);
            break;
          case "LDA":
            opcode = 500 + parseInt(instruction.opNumber);
            break;
          case "BRA":
            opcode = 600 + parseInt(instruction.opNumber);
            break;
          case "BRZ":
            opcode = 700 + parseInt(instruction.opNumber);
            break;
          case "BRP":
            opcode = 800 + parseInt(instruction.opNumber);
            break;
          case "INP":
            opcode = 901;
            break;
          case "OUT":
            opcode = 902;
            break;
          case "HLT":
            opcode = 0;
            break;
          default:
            opcode = parseInt(instruction.opNumber) || 0;
        }
        program.push(opcode);
      }
      // DAT entries are excluded from the program array
    });

    return program;
  }
}

export default LMC;
