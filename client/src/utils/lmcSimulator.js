/**
 * Little Man Computer (LMC) Simulator
 *
 * @class LMC
 */
class LMC {
  /**
   * Creates an instance of LMC.
   *
   * @param {number} [memorySize=100] - The size of the memory.
   */
  constructor(memorySize = 100) {
    this.memory = new Array(memorySize).fill("000");
    this.accumulator = 0;
    this.programCounter = 0;
    this.inputs = [];
    this.outputs = [];
    this.halted = false;
    this.isRunning = false;
    this.documentations = [];
    this.error = null;
    this.inputCallback = null;
    this.programIndices = [];
    this.totalProgramCounter = 0;
    this.delayTime = 1000;
    this.onStep = null;
  }

  /**
   * Sets the callback function to be used after each step.
   *
   * @param {Function} callback - The function to be called after each step.
   */
  setOnStepCallback(callback) {
    this.onStep = callback;
  }

  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  getError() {
    return this.error;
  }

  /**
   * Retrieves the total program counter.
   *
   * @returns {number} The value of the total program counter.
   */
  getTotalProgramCounter() {
    return this.totalProgramCounter;
  }

  /**
   * Retrieves the current value of the accumulator.
   *
   * @returns {number} The value stored in the accumulator.
   */
  getAccumulator() {
    return this.accumulator;
  }

  /**
   * Retrieves the current value of the program counter.
   *
   * @returns {number} The current program counter value.
   */
  getProgramCounter() {
    return this.programCounter;
  }

  /**
   * Retrieves the entire memory array of the LMC.
   *
   * @returns {string[]} The memory array containing all instructions and data.
   */
  getMemory() {
    return this.memory;
  }

  /**
   * Retrieves the halted state of the LMC.
   *
   * @returns {boolean} `true` if the LMC is halted, otherwise `false`.
   */
  getHaltedSatate() {
    return this.halted;
  }

  /**
   * Retrieves the indices where the program and data are stored in memory.
   *
   * @returns {number[]} An array of memory indices used by the program.
   */
  getProgramIndices() {
    return this.programIndices;
  }

  addToProgramIndices(index) {
    return (this.programIndices = [...this.programIndices, index]);
  }

  /**
   * Retrieves the documentation associated with the LMC program.
   *
   * @returns {Array} An array containing documentation entries.
   */
  getDocumentations() {
    return this.documentations;
  }

  /**
   * Retrieves the output values generated by the LMC program.
   *
   * @returns {Array} An array of output values.
   */
  getOutputs() {
    return this.outputs;
  }

  /**
   * Sets the callback function to be used for input operations.
   *
   * @param {Function} callback - The function to be called when input is required.
   */
  setInputCallback(callback) {
    this.inputCallback = callback;
  }

  /**
   * Loads a program into the LMC memory.
   *
   * @param {number[]} program - An array of instructions to load into memory.
   */
  loadProgram(program, instructions = []) {
    // Reset the LMC state
    this.reset();

    if (program.length > 100) {
      throw new Error("Program size exceeds memory capacity.");
    }

    this.totalProgramCounter = program.length;

    // Load program opcodes into memory
    program.forEach((instruction, index) => {
      if (instruction < 0 || instruction > 999) {
        throw new Error(
          `Invalid instruction at address ${index}: ${instruction}`
        );
      }
      this.memory[index] = instruction.toString().padStart(3, "0");
      this.programIndices.push(index);
    });

    if (instructions.length > 0) {
      // Load DAT values into memory
      instructions.forEach((instruction, index) => {
        if (instruction.data === "DAT") {
          const value =
            instruction.value === ""
              ? "000"
              : instruction.value.toString().padStart(3, "0");
          this.memory[index] = value;
          this.programIndices.push(index);
        }
      });
    }
  }

  /**
   * Executes a single instruction from memory.
   *
   * @throws {Error} If the program has halted or an invalid opcode is encountered.
   */
  step() {
    this.error = null;
    if (this.halted) {
      this.error = "Program has halted. Reset the program to run again.";
      throw new Error("Program is halted.");
    }

    if (this.programCounter < 0 || this.programCounter >= 100) {
      throw new Error(`Program counter out of bounds: ${this.programCounter}`);
    }

    const instruction = parseInt(this.memory[this.programCounter]);
    const opcode = Math.floor(instruction / 100);
    const address = instruction % 100;

    let docObj = {};

    switch (opcode) {
      case 1: // ADD
        this.accumulator += parseInt(this.memory[address]);

        docObj = {
          mnemonic: "ADD",
          opcode: instruction,
          mailbox: address,
          instruction: `ADD ${instruction}`,
          accumulator: this.accumulator,
          programCounter: this.programCounter + 1,
          comment: `ADD value at address ${address} to the value in the accumulator.`,
        };
        this.documentations.push(docObj);
        break;
      case 2: // SUB
        this.accumulator -= parseInt(this.memory[address]);

        docObj = {
          mnemonic: "SUB",
          opcode: instruction,
          mailbox: address,
          instruction: `SUB ${instruction}`,
          accumulator: this.accumulator,
          programCounter: this.programCounter + 1,
          comment: `SUB value at address ${address} from the value in the accumulator.`,
        };
        this.documentations.push(docObj);
        break;
      case 3: // STORE (STA)
        // if the value in the accumulator is not less then 0, do not pad it with zero
        if (this.accumulator < 0) {
          this.memory[address] = this.accumulator.toString();
        } else {
          this.memory[address] = this.accumulator.toString().padStart(3, "0");
        }

        // Add the address to the program indices if not already present
        if (this.programIndices.indexOf(address) === -1) {
          this.addToProgramIndices(address);
        }

        docObj = {
          mnemonic: "STA",
          opcode: instruction,
          mailbox: address,
          instruction: `STA ${instruction}`,
          accumulator: this.accumulator,
          programCounter: this.programCounter + 1,
          comment: `STORE the value in the accumulator at address ${address}.`,
        };
        this.documentations.push(docObj);
        break;
      case 5: // LOAD (LDA)
        this.accumulator = parseInt(this.memory[address]);

        docObj = {
          mnemonic: "LDA",
          opcode: instruction,
          mailbox: address,
          instruction: `LDA ${instruction}`,
          accumulator: this.accumulator,
          programCounter: this.programCounter + 1,
          comment: `LOAD the value at address ${address} into the accumulator.`,
        };
        this.documentations.push(docObj);
        break;
      case 6: // BRANCH (BRA)
        this.programCounter = address;
        docObj = {
          mnemonic: "BRA",
          opcode: instruction,
          mailbox: address,
          instruction: `BRA ${instruction}`,
          accumulator: this.accumulator,
          programCounter: this.programCounter,
          comment: `BRANCH to ${address}`,
        };
        this.documentations.push(docObj);
        return; // prevent incrementing the program counter
      case 7: // BRANCH IF ZERO (BRZ)
        if (this.accumulator === 0) {
          this.programCounter = address;

          docObj = {
            mnemonic: "BRZ",
            opcode: instruction,
            mailbox: address,
            instruction: `BRZ ${instruction}`,
            accumulator: this.accumulator,
            programCounter: this.programCounter,
            comment: `BRANCH to address ${address} if the accumulator value is zero.`,
          };
          this.documentations.push(docObj);
          return; // prevent incrementing the program counter
        }
        break;
      case 8: // BRANCH IF POSITIVE (BRP)
        if (this.accumulator >= 0) {
          this.programCounter = address;
          docObj = {
            mnemonic: "BRP",
            opcode: instruction,
            mailbox: address,
            instruction: `BRP ${instruction}`,
            accumulator: this.accumulator,
            programCounter: this.programCounter,
            comment: `BRANCH to address ${address} if the accumulator value is positive.`,
          };
          this.documentations.push(docObj);
          return;
        }
        break;
      case 9: // IO Operations
        if (address === 1) {
          //INP
          if (this.inputs.length === 0) {
            if (this.inputCallback) {
              this.halted = true;
              this.error = "Input required.";
            } else {
              throw new Error("Input buffer is empty.");
            }
          }
          const input = parseInt(this.inputs.shift(), 10);
          if (isNaN(input)) {
            throw new Error("Invalid input value: not a number.");
          }
          this.accumulator = input;
          docObj = {
            mnemonic: "INP",
            opcode: "901",
            mailbox: address,
            instruction: `INP 901`,
            accumulator: this.accumulator,
            programCounter: this.programCounter + 1,
            comment: `INPUT the value from the inbox (${this.accumulator}) into the accumulator.`,
          };
          this.documentations.push(docObj);
        } else if (address === 2) {
          //OUT
          this.outputs.push(this.accumulator);
          docObj = {
            mnemonic: "OUT",
            opcode: "902",
            mailbox: address,
            instruction: `OUT 902`,
            accumulator: this.accumulator,
            programCounter: this.programCounter + 1,
            comment: `OUTPUT the value in the accumulator (${this.accumulator}) to the outbox.`,
          };
          this.documentations.push(docObj);
        } else {
          throw new Error(`Invalid IO operation: ${address}`);
        }
        break;
      case 0:
        this.halted = true;
        docObj = {
          mnemonic: "HLT",
          opcode: "000",
          mailbox: address,
          instruction: `HLT 000`,
          accumulator: this.accumulator,
          programCounter: this.programCounter + 1,
          comment: `HALT program execution`,
        };
        this.documentations.push(docObj);
        break;
      default:
        throw new Error(`Invalid opcode: ${opcode}`);
    }
    this.programCounter++;
  }

  /**
   * Executes a single instruction from memory and logs the operation.
   */
  // In your LMC class (lmcSimulator.js)

  async stepProgram() {
    try {
      this.step();
      if (this.onStep) {
        this.onStep();
      }
    } catch (error) {
      if (this.error === "Input required.") {
        // Await user input via the input callback
        const input = await new Promise((resolve, reject) => {
          if (this.inputCallback) {
            this.inputCallback(
              "Input required. Please enter a value:",
              resolve
            );
          } else {
            reject(new Error("Input callback not set."));
          }
        });

        if (input !== null && input !== undefined) {
          this.setInbox(parseInt(input, 10)); // Ensure input is a number

          // Execute the step again with the input
          try {
            this.step();
            if (this.onStep) {
              this.onStep();
            }
          } catch (stepError) {
            if (this.error === "Input required.") {
              // Handle if another input is required
              const nextInput = await new Promise((resolve, reject) => {
                if (this.inputCallback) {
                  this.inputCallback(
                    "Input required. Please enter a value:",
                    resolve
                  );
                } else {
                  reject(new Error("Input callback not set."));
                }
              });

              if (nextInput !== null && nextInput !== undefined) {
                this.setInbox(parseInt(nextInput, 10));
                // Optionally, execute step again or handle further inputs
                this.step();
                if (this.onStep) {
                  this.onStep();
                }
              } else {
                throw new Error("Input was canceled by the user.");
              }
            } else {
              throw stepError;
            }
          }
        } else {
          throw new Error("Input was canceled by the user.");
        }
      } else {
        throw error; // Re-throw unexpected errors
      }
    }

    return Promise.resolve();
  }

  /**
   * Runs the loaded program until it halts, handling asynchronous input when required.
   */
  async run() {
    if (this.isRunning) {
      this.error = "Program is already running.";
      return Promise.reject(new Error(this.error));
    }

    this.isRunning = true;

    try {
      while (!this.halted && this.isRunning) {
        await this.delay(this.delayTime);

        try {
          this.step();
          if (this.onStep) {
            this.onStep();
          }
        } catch (error) {
          if (this.error === "Input required.") {
            // Await user input via the input callback
            const input = await new Promise((resolve, reject) => {
              if (this.inputCallback) {
                this.inputCallback(
                  "Input required. Please enter a value:",
                  resolve
                );
              } else {
                reject(new Error("Input callback not set."));
              }
            });

            if (input !== null && input !== undefined) {
              this.setInbox(parseInt(input, 10)); // Ensure input is a number
            } else {
              throw new Error("Input was canceled by the user.");
            }
          } else {
            throw error; // Re-throw unexpected errors
          }
        }
      }
      return Promise.resolve();
    } catch (error) {
      return Promise.reject(error);
    } finally {
      this.isRunning = false;
    }
  }

  /**
   * Stop program execution.
   */
  stopExecution() {
    if (this.isRunning) {
      this.isRunning = false;
    }
  }

  /**
   * Resets the LMC to its initial state.
   */
  reset() {
    this.memory.fill("000");
    this.accumulator = 0;
    this.programCounter = 0;
    this.inputs = [];
    this.outputs = [];
    this.halted = false;
    this.documentations = [];
    this.error = null;
    this.isRunning = false;
    this.programIndices = [];
  }

  /**
   * Adds a value to the input queue.
   *
   * @param {number} value - The value to be added to the input queue.
   */
  setInbox(input) {
    this.inputs = [input];

    if (this.error === "Input required.") {
      this.halted = false; // Resume execution
      this.error = null; // Clear the error message
    }
  }

  /**
   *
   * @param {number} address - The memory address to set the value.
   * @param {number} value - The value to set in the memory address.
   */
  setMemory(address, value) {
    this.memory[address] = value;
  }

  /**
   * Retrieves the logs.
   *
   * @returns {Array} The array of log entries.
   */
  getDocumentation() {
    return this.documentations;
  }

  convertToProgram(instructions) {
    let isDATPresent = false;

    instructions.forEach((instruction) => {
      if (instruction.data === "DAT") {
        isDATPresent = true;
      }
    });

    if (!isDATPresent) {
      return this.convertToProgramWithoutDAT(instructions);
    } else {
      return this.convertToProgramWithDAT(instructions);
    }
  }

  convertToProgramWithoutDAT(instructions) {
    let program = [];
    instructions.forEach((instruction) => {
      let opcode = 0;
      switch (instruction.mnemonic) {
        case "ADD":
          opcode = 100 + parseInt(instruction.address);
          break;
        case "SUB":
          opcode = 200 + parseInt(instruction.address);
          break;
        case "STA":
          opcode = 300 + parseInt(instruction.address);
          break;
        case "LDA":
          opcode = 500 + parseInt(instruction.address);
          break;
        case "BRA":
          opcode = 600 + parseInt(instruction.address);
          break;
        case "BRZ":
          opcode = 700 + parseInt(instruction.address);
          break;
        case "BRP":
          opcode = 800 + parseInt(instruction.address);
          break;
        case "INP":
          opcode = 901;
          break;
        case "OUT":
          opcode = 902;
          break;
        case "HLT":
          opcode = 0;
          break;
        default:
          opcode = 0;
      }
      program.push(opcode);
    });
    return program;
  }

  convertToProgramWithDAT(instructions) {
    // Create a map of labels and DAT addresses to their indices
    const labelMap = {};
    instructions.forEach((instruction, index) => {
      if (instruction.label) {
        labelMap[instruction.label] = index;
      }
      if (instruction.data === "DAT" && instruction.address) {
        labelMap[instruction.address] = index;
      }
    });

    // Assign opNumber to instructions referencing labels or numeric addresses
    instructions.forEach((instruction) => {
      // Handle mnemonic instructions (excluding DAT)
      if (
        instruction.mnemonic &&
        instruction.mnemonic !== "DAT" &&
        instruction.address
      ) {
        if (labelMap[instruction.address] !== undefined) {
          // Assign opNumber based on label/DAT index
          instruction.opNumber = labelMap[instruction.address].toString();
        } else {
          // If address is numeric, assign the parsed number as opNumber
          const parsedAddress = parseInt(instruction.address, 10);
          if (!isNaN(parsedAddress)) {
            instruction.opNumber = parsedAddress.toString();
          }
        }
      }

      // Handle DAT entries with numeric addresses
      if (instruction.data === "DAT" && instruction.address) {
        const parsedAddress = parseInt(instruction.address, 10);
        if (!isNaN(parsedAddress)) {
          instruction.opNumber = parsedAddress.toString();
        }
      }
    });

    // Generate program
    let program = [];
    instructions.forEach((instruction) => {
      if (instruction.data !== "DAT") {
        // Only process non-DAT instructions
        let opcode = 0;
        switch (instruction.mnemonic) {
          case "ADD":
            opcode = 100 + parseInt(instruction.opNumber);
            break;
          case "SUB":
            opcode = 200 + parseInt(instruction.opNumber);
            break;
          case "STA":
            opcode = 300 + parseInt(instruction.opNumber);
            break;
          case "LDA":
            opcode = 500 + parseInt(instruction.opNumber);
            break;
          case "BRA":
            opcode = 600 + parseInt(instruction.opNumber);
            break;
          case "BRZ":
            opcode = 700 + parseInt(instruction.opNumber);
            break;
          case "BRP":
            opcode = 800 + parseInt(instruction.opNumber);
            break;
          case "INP":
            opcode = 901;
            break;
          case "OUT":
            opcode = 902;
            break;
          case "HLT":
            opcode = 0;
            break;
          default:
            opcode = parseInt(instruction.opNumber) || 0;
        }
        program.push(opcode);
      }
      // DAT entries are excluded from the program array
    });

    return program;
  }
}

export default LMC;
